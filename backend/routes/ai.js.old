import express from "express";

const router = express.Router();

router.post("/extract", async (req, res) => {
  try {
    const { mime, dataBase64 } = req.body || {};
    if (!mime || !dataBase64) return res.status(400).json({ error: "Missing image" });

    const apiKey = process.env.GOOGLE_API_KEY;
    if (!apiKey) return res.status(500).json({ error: "Server missing GOOGLE_API_KEY" });

    const MODEL = "gemini-1.5-flash";

    const prompt = [
      "You are a receipt/slip parser for Thai/English payment slips.",
      "Return STRICT JSON ONLY with keys:",
      '{ "type":"income|expense", "amount": number, "category": string, "note": string, "datetime": string }',
      "Datetime must be ISO 8601 format (e.g. 2025-09-14T13:45:00). If not visible, use current date/time.",
      "Currency is THB. If not obvious, infer sensibly. Category from {Shopping, Pay Bill, Food, Transport, Groceries, Health, Entertainment, Education, Salary, Transfer, Other}.",
      "Do not include markdown fences."
    ].join("\n");

    const body = {
      contents: [
        {
          role: "user", parts: [
            { text: prompt },
            { inline_data: { mime_type: mime, data: dataBase64 } }
          ]
        }
      ]
    };

    const resp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${encodeURIComponent(apiKey)}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    if (!resp.ok) {
      const t = await resp.text();
      return res.status(502).json({ error: "Gemini error", detail: t });
    }

    const data = await resp.json();
    const text = (data?.candidates?.[0]?.content?.parts || []).map(p => p.text).join("\n") || "";
    const parsed = parseAI(text);
    return res.json(parsed);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "AI extract failed" });
  }
});

function parseAI(text) {
  const jsonMatch = text.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    try {
      const obj = JSON.parse(jsonMatch[0]);
      return normalize(obj);
    } catch { }
  }
  const lower = text.toLowerCase();
  const type = /(income|received|deposit)/.test(lower) ? "income" :
    /(expense|paid|pay|withdraw)/.test(lower) ? "expense" : "expense";
  const amtMatch = text.replace(/,/g, '').match(/(total|amount|paid|pay|price|sum|ยอด|จำนวน)\s*[:=]?\s*([\d.]+)/i) ||
    text.replace(/,/g, '').match(/\b([\d]+(?:\.[\d]{1,2})?)\b\s*(thb|baht|฿)?/i);
  const amount = amtMatch ? Number(amtMatch[2] || amtMatch[1]) : 0;
  const catMatch = lower.match(/(shopping|bill|pay bill|electricity|water|internet|food|groceries|transport|taxi|grab|education|tuition|health|hospital|salary|transfer)/);
  const map = {
    bill: "Pay Bill", electricity: "Pay Bill", water: "Pay Bill", internet: "Pay Bill", food: "Food", groceries: "Groceries",
    taxi: "Transport", grab: "Transport", education: "Education", tuition: "Education", health: "Health", hospital: "Health",
    salary: "Salary", transfer: "Transfer", shopping: "Shopping"
  };
  const category = catMatch ? (map[catMatch[1]] || firstUpper(catMatch[1])) : "Other";
  return {
    type,
    amount,
    category,
    note: "",
    datetime: new Date().toISOString() // fallback to now
  };
}


function normalize(obj) {
  return {
    type: (obj.type || obj.transaction_type || obj.income_expense || "expense").toString().toLowerCase() === "income" ? "income" : "expense",
    amount: Number(obj.amount ?? obj.total ?? obj.value ?? 0) || 0,
    category: obj.category || obj.tag || "Other",
    note: obj.note || obj.description || "",
    datetime: obj.datetime ? new Date(obj.datetime).toISOString() : new Date().toISOString()
  };
}
function firstUpper(s) { return s ? s[0].toUpperCase() + s.slice(1) : s; }

export default router;
